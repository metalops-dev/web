---
title: 'Kubernetes Deep Dive: Services and Networking'
description: 'Part 3 of the Kubernetes Deep Dive series - Exposing applications with Services'
pubDate: 2024-12-22
draft: true
tags: ['kubernetes', 'devops', 'networking']
series: 'Kubernetes Deep Dive'
seriesPart: 3
---

import SeriesBanner from '../../components/SeriesBanner.astro';

<SeriesBanner
  series="Kubernetes Deep Dive"
  part={3}
  totalParts={3}
  posts={[
    { title: "Introduction", slug: "k8s-deep-dive-1-intro", part: 1 },
    { title: "Pods and Deployments", slug: "k8s-deep-dive-2-pods", part: 2 },
    { title: "Services and Networking", slug: "k8s-deep-dive-3-networking", part: 3 },
  ]}
/>

In the final part of this series, we'll explore how to expose your applications using Services and configure networking in Kubernetes.

## The Networking Challenge

Pods are ephemeral ‚Äî they can be created, destroyed, and rescheduled at any time. Their IP addresses change. How do other pods or external users reach them?

**Services** solve this by providing a stable network endpoint.

## Service Types

```d2
direction: down

internet: Internet {
  shape: cloud
}

lb: LoadBalancer Service {
  shape: hexagon
}

np: NodePort Service {
  port: "30000-32767"
}

cip: ClusterIP Service {
  internal: "Cluster Only"
}

pods: Pods {
  p1: Pod 1
  p2: Pod 2
  p3: Pod 3
}

internet -> lb: External traffic
lb -> np
np -> cip
cip -> pods.p1
cip -> pods.p2
cip -> pods.p3
```

### ClusterIP (Default)

Internal-only access within the cluster:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: ClusterIP  # default
  selector:
    app: my-app
  ports:
  - port: 80
    targetPort: 8080
```

### NodePort

Exposes the service on each node's IP at a static port:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-nodeport-service
spec:
  type: NodePort
  selector:
    app: my-app
  ports:
  - port: 80
    targetPort: 8080
    nodePort: 30080  # optional, auto-assigned if omitted
```

### LoadBalancer

Creates an external load balancer (cloud providers):

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-loadbalancer
spec:
  type: LoadBalancer
  selector:
    app: my-app
  ports:
  - port: 80
    targetPort: 8080
```

## Ingress

For HTTP/HTTPS routing, use an **Ingress** resource:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx
  rules:
  - host: myapp.example.com
    http:
      paths:
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 80
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 80
```

## DNS in Kubernetes

Every Service gets a DNS name:

```
<service-name>.<namespace>.svc.cluster.local
```

```bash
# From within a pod
curl http://my-service.default.svc.cluster.local
curl http://my-service  # same namespace shorthand
```

## Network Policies

Control traffic flow between pods:

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all-ingress
spec:
  podSelector:
    matchLabels:
      app: secure-app
  policyTypes:
  - Ingress
  ingress: []  # empty = deny all
```

## Summary

In this series, we covered:

1. **Part 1** ‚Äî Kubernetes architecture and core concepts
2. **Part 2** ‚Äî Pods, Deployments, and resource management
3. **Part 3** ‚Äî Services, Ingress, and networking

### Next Steps

- Explore **ConfigMaps** and **Secrets** for configuration
- Learn about **StatefulSets** for stateful applications
- Set up **Monitoring** with Prometheus and Grafana
- Implement **GitOps** with ArgoCD or Flux

---

*‚Üê [Part 2: Pods and Deployments](/blog/k8s-deep-dive-2-pods/)*

---

**Series Complete!** üéâ

Thanks for following along. If you have questions, leave a comment below or reach out on GitHub.
